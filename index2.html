<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Solar System</title>

<style>
body {
  margin: 0;
  overflow: hidden;
  background: black;
  font-family: Arial, sans-serif;
}

#ui {
  position: absolute;
  top: 10px;
  left: 10px;
  background: rgba(0,0,0,0.7);
  color: white;
  padding: 15px;
  border-radius: 10px;
}

input {
  width: 200px;
}
</style>
</head>
<body>

<div id="ui">
  <h2>üåç Solar System Speed</h2>
  <input type="range" id="speedControl" min="0" max="5" step="0.1" value="1">
  <p>Speed Multiplier: <span id="speedValue">1</span>x</p>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>

<script>
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 10000);
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

camera.position.set(0, 300, 700);

// Controls (Touch Supported)
let controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableZoom = true;
controls.enableDamping = true;

// Lighting
let light = new THREE.PointLight(0xffffff, 2, 5000);
scene.add(light);

// Stars Background
let starGeometry = new THREE.BufferGeometry();
let starVertices = [];

for (let i = 0; i < 15000; i++) {
  starVertices.push((Math.random() - 0.5) * 8000);
  starVertices.push((Math.random() - 0.5) * 8000);
  starVertices.push((Math.random() - 0.5) * 8000);
}

starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
let starMaterial = new THREE.PointsMaterial({color: 0xffffff});
let stars = new THREE.Points(starGeometry, starMaterial);
scene.add(stars);

// Sun
let sun = new THREE.Mesh(
  new THREE.SphereGeometry(60, 64, 64),
  new THREE.MeshBasicMaterial({color: 0xffaa00})
);
scene.add(sun);

// Global Speed Control
let globalSpeed = 1;

document.getElementById("speedControl").addEventListener("input", function() {
  globalSpeed = parseFloat(this.value);
  document.getElementById("speedValue").innerText = globalSpeed;
});

// Planet Data
let planets = [
{name:"Mercury", size:6, dist:100, speed:0.04, color:0xb5b5b5, link:"mercury2.html"},
{name:"Venus", size:10, dist:140, speed:0.015, color:0xffcc99, link:"venus2.html"},
{name:"Earth", size:12, dist:180, speed:0.01, color:0x3399ff, link:"earth2.html"},
{name:"Mars", size:9, dist:220, speed:0.008, color:0xff3300, link:"mars2.html"},
{name:"Jupiter", size:30, dist:300, speed:0.002, color:0xff9966, link:"jupiter2.html"},
{name:"Saturn", size:26, dist:380, speed:0.001, color:0xffcc66, link:"saturn2.html"},
{name:"Uranus", size:18, dist:450, speed:0.0004, color:0x66ffff, link:"uranus2.html"},
{name:"Neptune", size:18, dist:520, speed:0.0002, color:0x3333ff, link:"neptune2.html"}
];

let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();

// Create Planets
planets.forEach(p => {

  let mesh = new THREE.Mesh(
    new THREE.SphereGeometry(p.size, 32, 32),
    new THREE.MeshStandardMaterial({color:p.color})
  );

  scene.add(mesh);
  p.mesh = mesh;
  p.angle = Math.random() * Math.PI * 2;

  // Orbit Line
  let orbitGeometry = new THREE.RingGeometry(p.dist - 1, p.dist + 1, 128);
  let orbitMaterial = new THREE.MeshBasicMaterial({color:0x444444, side:THREE.DoubleSide});
  let orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);
  orbit.rotation.x = Math.PI / 2;
  scene.add(orbit);
});

// Saturn Rings
let ringGeometry = new THREE.RingGeometry(30, 45, 64);
let ringMaterial = new THREE.MeshBasicMaterial({color:0xaaaaaa, side:THREE.DoubleSide});
let saturnRing = new THREE.Mesh(ringGeometry, ringMaterial);
saturnRing.rotation.x = Math.PI / 2;
planets[5].mesh.add(saturnRing);

// Click Event
window.addEventListener("click", function(event){
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);

  let intersects = raycaster.intersectObjects(planets.map(p => p.mesh));

  if(intersects.length > 0){
    let clickedPlanet = planets.find(p => p.mesh === intersects[0].object);
    window.location.href = clickedPlanet.link;
  }
});

// Animation
function animate(){
  requestAnimationFrame(animate);

  planets.forEach(p => {
    p.angle += p.speed * globalSpeed;
    p.mesh.position.x = p.dist * Math.cos(p.angle);
    p.mesh.position.z = p.dist * Math.sin(p.angle);
  });

  controls.update();
  renderer.render(scene, camera);
}

animate();

window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
