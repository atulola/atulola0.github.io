<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Advanced 3D Solar System</title>

<style>
body { margin: 0; overflow: hidden; background: black; font-family: Arial;}
#ui {
 position: absolute;
 top: 10px;
 left: 10px;
 background: rgba(0,0,0,0.7);
 color: white;
 padding: 15px;
 border-radius: 10px;
 font-size: 14px;
}
h2 {margin:0 0 10px 0;}
input { width:200px; }
</style>
</head>
<body>

<div id="ui">
<h2>üåç Solar System Speed</h2>
<input type="range" id="globalSpeed" min="0" max="5" step="0.1" value="1">
<p>Speed Multiplier: <span id="speedValue">1</span>x</p>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128/examples/js/controls/OrbitControls.js"></script>

<script>
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 10000);
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

camera.position.set(0,300,700);

// Controls (Mobile supported)
let controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableZoom = true;
controls.enableDamping = true;

// Lighting
let sunLight = new THREE.PointLight(0xffffff,2,5000);
scene.add(sunLight);

// Stars
let starGeo = new THREE.BufferGeometry();
let starVertices = [];
for(let i=0;i<15000;i++){
 starVertices.push((Math.random()-0.5)*8000);
 starVertices.push((Math.random()-0.5)*8000);
 starVertices.push((Math.random()-0.5)*8000);
}
starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starVertices,3));
let starMat = new THREE.PointsMaterial({color:0xffffff});
let stars = new THREE.Points(starGeo,starMat);
scene.add(stars);

// Sun
let sun = new THREE.Mesh(
 new THREE.SphereGeometry(60,64,64),
 new THREE.MeshBasicMaterial({color:0xffaa00})
);
scene.add(sun);

// Global Speed
let globalSpeed = 1;
document.getElementById("globalSpeed").addEventListener("input", function(){
 globalSpeed = parseFloat(this.value);
 document.getElementById("speedValue").innerText = globalSpeed;
});

// Planet Data
let planets = [
 {name:"Mercury", size:6, dist:100, speed:0.04, color:0xb5b5b5, link:"mercury.html"},
 {name:"Venus", size:10, dist:140, speed:0.015, color:0xffcc99, link:"venus.html"},
 {name:"Earth", size:12, dist:180, speed:0.01, color:0x3399ff, link:"earth.html"},
 {name:"Mars", size:9, dist:220, speed:0.008, color:0xff3300, link:"mars.html"},
 {name:"Jupiter", size:30, dist:300, speed:0.002, color:0xff9966, link:"jupiter.html"},
 {name:"Saturn", size:26, dist:380, speed:0.001, color:0xffcc66, link:"saturn.html"},
 {name:"Uranus", size:18, dist:450, speed:0.0004, color:0x66ffff, link:"uranus.html"},
 {name:"Neptune", size:18, dist:520, speed:0.0002, color:0x3333ff, link:"neptune.html"}
];

let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();

// Asteroid Belt
for(let i=0;i<2000;i++){
 let asteroid = new THREE.Mesh(
  new THREE.SphereGeometry(1,6,6),
  new THREE.MeshStandardMaterial({color:0x888888})
 );
 let angle = Math.random()*Math.PI*2;
 let radius = 260 + Math.random()*40;
 asteroid.position.set(
  radius*Math.cos(angle),
  (Math.random()-0.5)*10,
  radius*Math.sin(angle)
 );
 scene.add(asteroid);
}

// Create Planets
planets.forEach(p=>{
 let mesh = new THREE.Mesh(
  new THREE.SphereGeometry(p.size,32,32),
  new THREE.MeshStandardMaterial({color:p.color})
 );
 scene.add(mesh);
 p.mesh = mesh;
 p.angle = Math.random()*Math.PI*2;

 // Orbit line
 let orbitGeo = new THREE.RingGeometry(p.dist-1, p.dist+1, 128);
 let orbitMat = new THREE.MeshBasicMaterial({color:0x444444, side:THREE.DoubleSide});
 let orbit = new THREE.Mesh(orbitGeo, orbitMat);
 orbit.rotation.x = Math.PI/2;
 scene.add(orbit);
});

// Saturn Rings
let ringGeo = new THREE.RingGeometry(30,45,64);
let ringMat = new THREE.MeshBasicMaterial({color:0xaaaaaa, side:THREE.DoubleSide});
let saturnRing = new THREE.Mesh(ringGeo, ringMat);
saturnRing.rotation.x = Math.PI/2;
planets[5].mesh.add(saturnRing);

// Click Event
window.addEventListener('click', function(event){
 mouse.x = (event.clientX/window.innerWidth)*2-1;
 mouse.y = -(event.clientY/window.innerHeight)*2+1;
 raycaster.setFromCamera(mouse,camera);
 let intersects = raycaster.intersectObjects(planets.map(p=>p.mesh));
 if(intersects.length>0){
   let clicked = planets.find(p=>p.mesh===intersects[0].object);
   window.location.href = clicked.link;
 }
});

// Animation
function animate(){
 requestAnimationFrame(animate);
 planets.forEach(p=>{
   p.angle += p.speed * globalSpeed;
   p.mesh.position.x = p.dist*Math.cos(p.angle);
   p.mesh.position.z = p.dist*Math.sin(p.angle);
 });
 controls.update();
 renderer.render(scene,camera);
}
animate();

window.addEventListener("resize",()=>{
 camera.aspect=window.innerWidth/window.innerHeight;
 camera.updateProjectionMatrix();
 renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
